// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'edit_group_plan_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

EditGroupPlanRequestModel _$EditGroupPlanRequestModelFromJson(
    Map<String, dynamic> json) {
  return _EditGroupPlanRequestModel.fromJson(json);
}

/// @nodoc
mixin _$EditGroupPlanRequestModel {
  @JsonKey(name: "groupId")
  String? get groupId => throw _privateConstructorUsedError;
  @JsonKey(name: "productId")
  String? get productId => throw _privateConstructorUsedError;
  @JsonKey(name: "monthlyPlanId")
  String? get monthlyPlanId => throw _privateConstructorUsedError;
  @JsonKey(name: "monthlyPlanAmount")
  int? get monthlyPlanAmount => throw _privateConstructorUsedError;
  @JsonKey(name: "yearlyPlanId")
  String? get yearlyPlanId => throw _privateConstructorUsedError;
  @JsonKey(name: "yearlyPlanAmount")
  int? get yearlyPlanAmount => throw _privateConstructorUsedError;
  @JsonKey(name: "quartPlanId")
  String? get quartPlanId => throw _privateConstructorUsedError;
  @JsonKey(name: "quartPlanAmount")
  int? get quartPlanAmount => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EditGroupPlanRequestModelCopyWith<EditGroupPlanRequestModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditGroupPlanRequestModelCopyWith<$Res> {
  factory $EditGroupPlanRequestModelCopyWith(EditGroupPlanRequestModel value,
          $Res Function(EditGroupPlanRequestModel) then) =
      _$EditGroupPlanRequestModelCopyWithImpl<$Res, EditGroupPlanRequestModel>;
  @useResult
  $Res call(
      {@JsonKey(name: "groupId") String? groupId,
      @JsonKey(name: "productId") String? productId,
      @JsonKey(name: "monthlyPlanId") String? monthlyPlanId,
      @JsonKey(name: "monthlyPlanAmount") int? monthlyPlanAmount,
      @JsonKey(name: "yearlyPlanId") String? yearlyPlanId,
      @JsonKey(name: "yearlyPlanAmount") int? yearlyPlanAmount,
      @JsonKey(name: "quartPlanId") String? quartPlanId,
      @JsonKey(name: "quartPlanAmount") int? quartPlanAmount});
}

/// @nodoc
class _$EditGroupPlanRequestModelCopyWithImpl<$Res,
        $Val extends EditGroupPlanRequestModel>
    implements $EditGroupPlanRequestModelCopyWith<$Res> {
  _$EditGroupPlanRequestModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groupId = freezed,
    Object? productId = freezed,
    Object? monthlyPlanId = freezed,
    Object? monthlyPlanAmount = freezed,
    Object? yearlyPlanId = freezed,
    Object? yearlyPlanAmount = freezed,
    Object? quartPlanId = freezed,
    Object? quartPlanAmount = freezed,
  }) {
    return _then(_value.copyWith(
      groupId: freezed == groupId
          ? _value.groupId
          : groupId // ignore: cast_nullable_to_non_nullable
              as String?,
      productId: freezed == productId
          ? _value.productId
          : productId // ignore: cast_nullable_to_non_nullable
              as String?,
      monthlyPlanId: freezed == monthlyPlanId
          ? _value.monthlyPlanId
          : monthlyPlanId // ignore: cast_nullable_to_non_nullable
              as String?,
      monthlyPlanAmount: freezed == monthlyPlanAmount
          ? _value.monthlyPlanAmount
          : monthlyPlanAmount // ignore: cast_nullable_to_non_nullable
              as int?,
      yearlyPlanId: freezed == yearlyPlanId
          ? _value.yearlyPlanId
          : yearlyPlanId // ignore: cast_nullable_to_non_nullable
              as String?,
      yearlyPlanAmount: freezed == yearlyPlanAmount
          ? _value.yearlyPlanAmount
          : yearlyPlanAmount // ignore: cast_nullable_to_non_nullable
              as int?,
      quartPlanId: freezed == quartPlanId
          ? _value.quartPlanId
          : quartPlanId // ignore: cast_nullable_to_non_nullable
              as String?,
      quartPlanAmount: freezed == quartPlanAmount
          ? _value.quartPlanAmount
          : quartPlanAmount // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EditGroupPlanRequestModelImplCopyWith<$Res>
    implements $EditGroupPlanRequestModelCopyWith<$Res> {
  factory _$$EditGroupPlanRequestModelImplCopyWith(
          _$EditGroupPlanRequestModelImpl value,
          $Res Function(_$EditGroupPlanRequestModelImpl) then) =
      __$$EditGroupPlanRequestModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: "groupId") String? groupId,
      @JsonKey(name: "productId") String? productId,
      @JsonKey(name: "monthlyPlanId") String? monthlyPlanId,
      @JsonKey(name: "monthlyPlanAmount") int? monthlyPlanAmount,
      @JsonKey(name: "yearlyPlanId") String? yearlyPlanId,
      @JsonKey(name: "yearlyPlanAmount") int? yearlyPlanAmount,
      @JsonKey(name: "quartPlanId") String? quartPlanId,
      @JsonKey(name: "quartPlanAmount") int? quartPlanAmount});
}

/// @nodoc
class __$$EditGroupPlanRequestModelImplCopyWithImpl<$Res>
    extends _$EditGroupPlanRequestModelCopyWithImpl<$Res,
        _$EditGroupPlanRequestModelImpl>
    implements _$$EditGroupPlanRequestModelImplCopyWith<$Res> {
  __$$EditGroupPlanRequestModelImplCopyWithImpl(
      _$EditGroupPlanRequestModelImpl _value,
      $Res Function(_$EditGroupPlanRequestModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groupId = freezed,
    Object? productId = freezed,
    Object? monthlyPlanId = freezed,
    Object? monthlyPlanAmount = freezed,
    Object? yearlyPlanId = freezed,
    Object? yearlyPlanAmount = freezed,
    Object? quartPlanId = freezed,
    Object? quartPlanAmount = freezed,
  }) {
    return _then(_$EditGroupPlanRequestModelImpl(
      groupId: freezed == groupId
          ? _value.groupId
          : groupId // ignore: cast_nullable_to_non_nullable
              as String?,
      productId: freezed == productId
          ? _value.productId
          : productId // ignore: cast_nullable_to_non_nullable
              as String?,
      monthlyPlanId: freezed == monthlyPlanId
          ? _value.monthlyPlanId
          : monthlyPlanId // ignore: cast_nullable_to_non_nullable
              as String?,
      monthlyPlanAmount: freezed == monthlyPlanAmount
          ? _value.monthlyPlanAmount
          : monthlyPlanAmount // ignore: cast_nullable_to_non_nullable
              as int?,
      yearlyPlanId: freezed == yearlyPlanId
          ? _value.yearlyPlanId
          : yearlyPlanId // ignore: cast_nullable_to_non_nullable
              as String?,
      yearlyPlanAmount: freezed == yearlyPlanAmount
          ? _value.yearlyPlanAmount
          : yearlyPlanAmount // ignore: cast_nullable_to_non_nullable
              as int?,
      quartPlanId: freezed == quartPlanId
          ? _value.quartPlanId
          : quartPlanId // ignore: cast_nullable_to_non_nullable
              as String?,
      quartPlanAmount: freezed == quartPlanAmount
          ? _value.quartPlanAmount
          : quartPlanAmount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EditGroupPlanRequestModelImpl implements _EditGroupPlanRequestModel {
  const _$EditGroupPlanRequestModelImpl(
      {@JsonKey(name: "groupId") this.groupId,
      @JsonKey(name: "productId") this.productId,
      @JsonKey(name: "monthlyPlanId") this.monthlyPlanId,
      @JsonKey(name: "monthlyPlanAmount") this.monthlyPlanAmount,
      @JsonKey(name: "yearlyPlanId") this.yearlyPlanId,
      @JsonKey(name: "yearlyPlanAmount") this.yearlyPlanAmount,
      @JsonKey(name: "quartPlanId") this.quartPlanId,
      @JsonKey(name: "quartPlanAmount") this.quartPlanAmount});

  factory _$EditGroupPlanRequestModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$EditGroupPlanRequestModelImplFromJson(json);

  @override
  @JsonKey(name: "groupId")
  final String? groupId;
  @override
  @JsonKey(name: "productId")
  final String? productId;
  @override
  @JsonKey(name: "monthlyPlanId")
  final String? monthlyPlanId;
  @override
  @JsonKey(name: "monthlyPlanAmount")
  final int? monthlyPlanAmount;
  @override
  @JsonKey(name: "yearlyPlanId")
  final String? yearlyPlanId;
  @override
  @JsonKey(name: "yearlyPlanAmount")
  final int? yearlyPlanAmount;
  @override
  @JsonKey(name: "quartPlanId")
  final String? quartPlanId;
  @override
  @JsonKey(name: "quartPlanAmount")
  final int? quartPlanAmount;

  @override
  String toString() {
    return 'EditGroupPlanRequestModel(groupId: $groupId, productId: $productId, monthlyPlanId: $monthlyPlanId, monthlyPlanAmount: $monthlyPlanAmount, yearlyPlanId: $yearlyPlanId, yearlyPlanAmount: $yearlyPlanAmount, quartPlanId: $quartPlanId, quartPlanAmount: $quartPlanAmount)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EditGroupPlanRequestModelImpl &&
            (identical(other.groupId, groupId) || other.groupId == groupId) &&
            (identical(other.productId, productId) ||
                other.productId == productId) &&
            (identical(other.monthlyPlanId, monthlyPlanId) ||
                other.monthlyPlanId == monthlyPlanId) &&
            (identical(other.monthlyPlanAmount, monthlyPlanAmount) ||
                other.monthlyPlanAmount == monthlyPlanAmount) &&
            (identical(other.yearlyPlanId, yearlyPlanId) ||
                other.yearlyPlanId == yearlyPlanId) &&
            (identical(other.yearlyPlanAmount, yearlyPlanAmount) ||
                other.yearlyPlanAmount == yearlyPlanAmount) &&
            (identical(other.quartPlanId, quartPlanId) ||
                other.quartPlanId == quartPlanId) &&
            (identical(other.quartPlanAmount, quartPlanAmount) ||
                other.quartPlanAmount == quartPlanAmount));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      groupId,
      productId,
      monthlyPlanId,
      monthlyPlanAmount,
      yearlyPlanId,
      yearlyPlanAmount,
      quartPlanId,
      quartPlanAmount);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EditGroupPlanRequestModelImplCopyWith<_$EditGroupPlanRequestModelImpl>
      get copyWith => __$$EditGroupPlanRequestModelImplCopyWithImpl<
          _$EditGroupPlanRequestModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EditGroupPlanRequestModelImplToJson(
      this,
    );
  }
}

abstract class _EditGroupPlanRequestModel implements EditGroupPlanRequestModel {
  const factory _EditGroupPlanRequestModel(
          {@JsonKey(name: "groupId") final String? groupId,
          @JsonKey(name: "productId") final String? productId,
          @JsonKey(name: "monthlyPlanId") final String? monthlyPlanId,
          @JsonKey(name: "monthlyPlanAmount") final int? monthlyPlanAmount,
          @JsonKey(name: "yearlyPlanId") final String? yearlyPlanId,
          @JsonKey(name: "yearlyPlanAmount") final int? yearlyPlanAmount,
          @JsonKey(name: "quartPlanId") final String? quartPlanId,
          @JsonKey(name: "quartPlanAmount") final int? quartPlanAmount}) =
      _$EditGroupPlanRequestModelImpl;

  factory _EditGroupPlanRequestModel.fromJson(Map<String, dynamic> json) =
      _$EditGroupPlanRequestModelImpl.fromJson;

  @override
  @JsonKey(name: "groupId")
  String? get groupId;
  @override
  @JsonKey(name: "productId")
  String? get productId;
  @override
  @JsonKey(name: "monthlyPlanId")
  String? get monthlyPlanId;
  @override
  @JsonKey(name: "monthlyPlanAmount")
  int? get monthlyPlanAmount;
  @override
  @JsonKey(name: "yearlyPlanId")
  String? get yearlyPlanId;
  @override
  @JsonKey(name: "yearlyPlanAmount")
  int? get yearlyPlanAmount;
  @override
  @JsonKey(name: "quartPlanId")
  String? get quartPlanId;
  @override
  @JsonKey(name: "quartPlanAmount")
  int? get quartPlanAmount;
  @override
  @JsonKey(ignore: true)
  _$$EditGroupPlanRequestModelImplCopyWith<_$EditGroupPlanRequestModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}

EditGroupPlanResponseModel _$EditGroupPlanResponseModelFromJson(
    Map<String, dynamic> json) {
  return _EditGroupPlanResponseModel.fromJson(json);
}

/// @nodoc
mixin _$EditGroupPlanResponseModel {
  @JsonKey(name: "code")
  int? get code => throw _privateConstructorUsedError;
  @JsonKey(name: "message")
  String? get message => throw _privateConstructorUsedError;
  @JsonKey(name: "isSuccess")
  bool? get isSuccess => throw _privateConstructorUsedError;
  @JsonKey(name: "data")
  Data? get data => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $EditGroupPlanResponseModelCopyWith<EditGroupPlanResponseModel>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EditGroupPlanResponseModelCopyWith<$Res> {
  factory $EditGroupPlanResponseModelCopyWith(EditGroupPlanResponseModel value,
          $Res Function(EditGroupPlanResponseModel) then) =
      _$EditGroupPlanResponseModelCopyWithImpl<$Res,
          EditGroupPlanResponseModel>;
  @useResult
  $Res call(
      {@JsonKey(name: "code") int? code,
      @JsonKey(name: "message") String? message,
      @JsonKey(name: "isSuccess") bool? isSuccess,
      @JsonKey(name: "data") Data? data});

  $DataCopyWith<$Res>? get data;
}

/// @nodoc
class _$EditGroupPlanResponseModelCopyWithImpl<$Res,
        $Val extends EditGroupPlanResponseModel>
    implements $EditGroupPlanResponseModelCopyWith<$Res> {
  _$EditGroupPlanResponseModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = freezed,
    Object? message = freezed,
    Object? isSuccess = freezed,
    Object? data = freezed,
  }) {
    return _then(_value.copyWith(
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as int?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      isSuccess: freezed == isSuccess
          ? _value.isSuccess
          : isSuccess // ignore: cast_nullable_to_non_nullable
              as bool?,
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as Data?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $DataCopyWith<$Res>? get data {
    if (_value.data == null) {
      return null;
    }

    return $DataCopyWith<$Res>(_value.data!, (value) {
      return _then(_value.copyWith(data: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$EditGroupPlanResponseModelImplCopyWith<$Res>
    implements $EditGroupPlanResponseModelCopyWith<$Res> {
  factory _$$EditGroupPlanResponseModelImplCopyWith(
          _$EditGroupPlanResponseModelImpl value,
          $Res Function(_$EditGroupPlanResponseModelImpl) then) =
      __$$EditGroupPlanResponseModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: "code") int? code,
      @JsonKey(name: "message") String? message,
      @JsonKey(name: "isSuccess") bool? isSuccess,
      @JsonKey(name: "data") Data? data});

  @override
  $DataCopyWith<$Res>? get data;
}

/// @nodoc
class __$$EditGroupPlanResponseModelImplCopyWithImpl<$Res>
    extends _$EditGroupPlanResponseModelCopyWithImpl<$Res,
        _$EditGroupPlanResponseModelImpl>
    implements _$$EditGroupPlanResponseModelImplCopyWith<$Res> {
  __$$EditGroupPlanResponseModelImplCopyWithImpl(
      _$EditGroupPlanResponseModelImpl _value,
      $Res Function(_$EditGroupPlanResponseModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? code = freezed,
    Object? message = freezed,
    Object? isSuccess = freezed,
    Object? data = freezed,
  }) {
    return _then(_$EditGroupPlanResponseModelImpl(
      code: freezed == code
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as int?,
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
      isSuccess: freezed == isSuccess
          ? _value.isSuccess
          : isSuccess // ignore: cast_nullable_to_non_nullable
              as bool?,
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as Data?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$EditGroupPlanResponseModelImpl implements _EditGroupPlanResponseModel {
  const _$EditGroupPlanResponseModelImpl(
      {@JsonKey(name: "code") this.code,
      @JsonKey(name: "message") this.message,
      @JsonKey(name: "isSuccess") this.isSuccess,
      @JsonKey(name: "data") this.data});

  factory _$EditGroupPlanResponseModelImpl.fromJson(
          Map<String, dynamic> json) =>
      _$$EditGroupPlanResponseModelImplFromJson(json);

  @override
  @JsonKey(name: "code")
  final int? code;
  @override
  @JsonKey(name: "message")
  final String? message;
  @override
  @JsonKey(name: "isSuccess")
  final bool? isSuccess;
  @override
  @JsonKey(name: "data")
  final Data? data;

  @override
  String toString() {
    return 'EditGroupPlanResponseModel(code: $code, message: $message, isSuccess: $isSuccess, data: $data)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EditGroupPlanResponseModelImpl &&
            (identical(other.code, code) || other.code == code) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.isSuccess, isSuccess) ||
                other.isSuccess == isSuccess) &&
            (identical(other.data, data) || other.data == data));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, code, message, isSuccess, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EditGroupPlanResponseModelImplCopyWith<_$EditGroupPlanResponseModelImpl>
      get copyWith => __$$EditGroupPlanResponseModelImplCopyWithImpl<
          _$EditGroupPlanResponseModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$EditGroupPlanResponseModelImplToJson(
      this,
    );
  }
}

abstract class _EditGroupPlanResponseModel
    implements EditGroupPlanResponseModel {
  const factory _EditGroupPlanResponseModel(
          {@JsonKey(name: "code") final int? code,
          @JsonKey(name: "message") final String? message,
          @JsonKey(name: "isSuccess") final bool? isSuccess,
          @JsonKey(name: "data") final Data? data}) =
      _$EditGroupPlanResponseModelImpl;

  factory _EditGroupPlanResponseModel.fromJson(Map<String, dynamic> json) =
      _$EditGroupPlanResponseModelImpl.fromJson;

  @override
  @JsonKey(name: "code")
  int? get code;
  @override
  @JsonKey(name: "message")
  String? get message;
  @override
  @JsonKey(name: "isSuccess")
  bool? get isSuccess;
  @override
  @JsonKey(name: "data")
  Data? get data;
  @override
  @JsonKey(ignore: true)
  _$$EditGroupPlanResponseModelImplCopyWith<_$EditGroupPlanResponseModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}

Data _$DataFromJson(Map<String, dynamic> json) {
  return _Data.fromJson(json);
}

/// @nodoc
mixin _$Data {
  @JsonKey(name: "monthPlanCreate")
  PlanCreate? get monthPlanCreate => throw _privateConstructorUsedError;
  @JsonKey(name: "yearlyPlanCreate")
  PlanCreate? get yearlyPlanCreate => throw _privateConstructorUsedError;
  @JsonKey(name: "quadPlanCreate")
  PlanCreate? get quadPlanCreate => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DataCopyWith<Data> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DataCopyWith<$Res> {
  factory $DataCopyWith(Data value, $Res Function(Data) then) =
      _$DataCopyWithImpl<$Res, Data>;
  @useResult
  $Res call(
      {@JsonKey(name: "monthPlanCreate") PlanCreate? monthPlanCreate,
      @JsonKey(name: "yearlyPlanCreate") PlanCreate? yearlyPlanCreate,
      @JsonKey(name: "quadPlanCreate") PlanCreate? quadPlanCreate});

  $PlanCreateCopyWith<$Res>? get monthPlanCreate;
  $PlanCreateCopyWith<$Res>? get yearlyPlanCreate;
  $PlanCreateCopyWith<$Res>? get quadPlanCreate;
}

/// @nodoc
class _$DataCopyWithImpl<$Res, $Val extends Data>
    implements $DataCopyWith<$Res> {
  _$DataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? monthPlanCreate = freezed,
    Object? yearlyPlanCreate = freezed,
    Object? quadPlanCreate = freezed,
  }) {
    return _then(_value.copyWith(
      monthPlanCreate: freezed == monthPlanCreate
          ? _value.monthPlanCreate
          : monthPlanCreate // ignore: cast_nullable_to_non_nullable
              as PlanCreate?,
      yearlyPlanCreate: freezed == yearlyPlanCreate
          ? _value.yearlyPlanCreate
          : yearlyPlanCreate // ignore: cast_nullable_to_non_nullable
              as PlanCreate?,
      quadPlanCreate: freezed == quadPlanCreate
          ? _value.quadPlanCreate
          : quadPlanCreate // ignore: cast_nullable_to_non_nullable
              as PlanCreate?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $PlanCreateCopyWith<$Res>? get monthPlanCreate {
    if (_value.monthPlanCreate == null) {
      return null;
    }

    return $PlanCreateCopyWith<$Res>(_value.monthPlanCreate!, (value) {
      return _then(_value.copyWith(monthPlanCreate: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PlanCreateCopyWith<$Res>? get yearlyPlanCreate {
    if (_value.yearlyPlanCreate == null) {
      return null;
    }

    return $PlanCreateCopyWith<$Res>(_value.yearlyPlanCreate!, (value) {
      return _then(_value.copyWith(yearlyPlanCreate: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PlanCreateCopyWith<$Res>? get quadPlanCreate {
    if (_value.quadPlanCreate == null) {
      return null;
    }

    return $PlanCreateCopyWith<$Res>(_value.quadPlanCreate!, (value) {
      return _then(_value.copyWith(quadPlanCreate: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$DataImplCopyWith<$Res> implements $DataCopyWith<$Res> {
  factory _$$DataImplCopyWith(
          _$DataImpl value, $Res Function(_$DataImpl) then) =
      __$$DataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: "monthPlanCreate") PlanCreate? monthPlanCreate,
      @JsonKey(name: "yearlyPlanCreate") PlanCreate? yearlyPlanCreate,
      @JsonKey(name: "quadPlanCreate") PlanCreate? quadPlanCreate});

  @override
  $PlanCreateCopyWith<$Res>? get monthPlanCreate;
  @override
  $PlanCreateCopyWith<$Res>? get yearlyPlanCreate;
  @override
  $PlanCreateCopyWith<$Res>? get quadPlanCreate;
}

/// @nodoc
class __$$DataImplCopyWithImpl<$Res>
    extends _$DataCopyWithImpl<$Res, _$DataImpl>
    implements _$$DataImplCopyWith<$Res> {
  __$$DataImplCopyWithImpl(_$DataImpl _value, $Res Function(_$DataImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? monthPlanCreate = freezed,
    Object? yearlyPlanCreate = freezed,
    Object? quadPlanCreate = freezed,
  }) {
    return _then(_$DataImpl(
      monthPlanCreate: freezed == monthPlanCreate
          ? _value.monthPlanCreate
          : monthPlanCreate // ignore: cast_nullable_to_non_nullable
              as PlanCreate?,
      yearlyPlanCreate: freezed == yearlyPlanCreate
          ? _value.yearlyPlanCreate
          : yearlyPlanCreate // ignore: cast_nullable_to_non_nullable
              as PlanCreate?,
      quadPlanCreate: freezed == quadPlanCreate
          ? _value.quadPlanCreate
          : quadPlanCreate // ignore: cast_nullable_to_non_nullable
              as PlanCreate?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DataImpl implements _Data {
  const _$DataImpl(
      {@JsonKey(name: "monthPlanCreate") this.monthPlanCreate,
      @JsonKey(name: "yearlyPlanCreate") this.yearlyPlanCreate,
      @JsonKey(name: "quadPlanCreate") this.quadPlanCreate});

  factory _$DataImpl.fromJson(Map<String, dynamic> json) =>
      _$$DataImplFromJson(json);

  @override
  @JsonKey(name: "monthPlanCreate")
  final PlanCreate? monthPlanCreate;
  @override
  @JsonKey(name: "yearlyPlanCreate")
  final PlanCreate? yearlyPlanCreate;
  @override
  @JsonKey(name: "quadPlanCreate")
  final PlanCreate? quadPlanCreate;

  @override
  String toString() {
    return 'Data(monthPlanCreate: $monthPlanCreate, yearlyPlanCreate: $yearlyPlanCreate, quadPlanCreate: $quadPlanCreate)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataImpl &&
            (identical(other.monthPlanCreate, monthPlanCreate) ||
                other.monthPlanCreate == monthPlanCreate) &&
            (identical(other.yearlyPlanCreate, yearlyPlanCreate) ||
                other.yearlyPlanCreate == yearlyPlanCreate) &&
            (identical(other.quadPlanCreate, quadPlanCreate) ||
                other.quadPlanCreate == quadPlanCreate));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType, monthPlanCreate, yearlyPlanCreate, quadPlanCreate);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DataImplCopyWith<_$DataImpl> get copyWith =>
      __$$DataImplCopyWithImpl<_$DataImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DataImplToJson(
      this,
    );
  }
}

abstract class _Data implements Data {
  const factory _Data(
          {@JsonKey(name: "monthPlanCreate") final PlanCreate? monthPlanCreate,
          @JsonKey(name: "yearlyPlanCreate") final PlanCreate? yearlyPlanCreate,
          @JsonKey(name: "quadPlanCreate") final PlanCreate? quadPlanCreate}) =
      _$DataImpl;

  factory _Data.fromJson(Map<String, dynamic> json) = _$DataImpl.fromJson;

  @override
  @JsonKey(name: "monthPlanCreate")
  PlanCreate? get monthPlanCreate;
  @override
  @JsonKey(name: "yearlyPlanCreate")
  PlanCreate? get yearlyPlanCreate;
  @override
  @JsonKey(name: "quadPlanCreate")
  PlanCreate? get quadPlanCreate;
  @override
  @JsonKey(ignore: true)
  _$$DataImplCopyWith<_$DataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PlanCreate _$PlanCreateFromJson(Map<String, dynamic> json) {
  return _PlanCreate.fromJson(json);
}

/// @nodoc
mixin _$PlanCreate {
  @JsonKey(name: "id")
  String? get id => throw _privateConstructorUsedError;
  @JsonKey(name: "object")
  String? get object => throw _privateConstructorUsedError;
  @JsonKey(name: "active")
  bool? get active => throw _privateConstructorUsedError;
  @JsonKey(name: "aggregate_usage")
  dynamic get aggregateUsage => throw _privateConstructorUsedError;
  @JsonKey(name: "amount")
  int? get amount => throw _privateConstructorUsedError;
  @JsonKey(name: "amount_decimal")
  String? get amountDecimal => throw _privateConstructorUsedError;
  @JsonKey(name: "billing_scheme")
  String? get billingScheme => throw _privateConstructorUsedError;
  @JsonKey(name: "created")
  int? get created => throw _privateConstructorUsedError;
  @JsonKey(name: "currency")
  String? get currency => throw _privateConstructorUsedError;
  @JsonKey(name: "interval")
  String? get interval => throw _privateConstructorUsedError;
  @JsonKey(name: "interval_count")
  int? get intervalCount => throw _privateConstructorUsedError;
  @JsonKey(name: "livemode")
  bool? get livemode => throw _privateConstructorUsedError;
  @JsonKey(name: "metadata")
  Metadata? get metadata => throw _privateConstructorUsedError;
  @JsonKey(name: "nickname")
  String? get nickname => throw _privateConstructorUsedError;
  @JsonKey(name: "product")
  String? get product => throw _privateConstructorUsedError;
  @JsonKey(name: "tiers_mode")
  dynamic get tiersMode => throw _privateConstructorUsedError;
  @JsonKey(name: "transform_usage")
  dynamic get transformUsage => throw _privateConstructorUsedError;
  @JsonKey(name: "trial_period_days")
  dynamic get trialPeriodDays => throw _privateConstructorUsedError;
  @JsonKey(name: "usage_type")
  String? get usageType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PlanCreateCopyWith<PlanCreate> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PlanCreateCopyWith<$Res> {
  factory $PlanCreateCopyWith(
          PlanCreate value, $Res Function(PlanCreate) then) =
      _$PlanCreateCopyWithImpl<$Res, PlanCreate>;
  @useResult
  $Res call(
      {@JsonKey(name: "id") String? id,
      @JsonKey(name: "object") String? object,
      @JsonKey(name: "active") bool? active,
      @JsonKey(name: "aggregate_usage") dynamic aggregateUsage,
      @JsonKey(name: "amount") int? amount,
      @JsonKey(name: "amount_decimal") String? amountDecimal,
      @JsonKey(name: "billing_scheme") String? billingScheme,
      @JsonKey(name: "created") int? created,
      @JsonKey(name: "currency") String? currency,
      @JsonKey(name: "interval") String? interval,
      @JsonKey(name: "interval_count") int? intervalCount,
      @JsonKey(name: "livemode") bool? livemode,
      @JsonKey(name: "metadata") Metadata? metadata,
      @JsonKey(name: "nickname") String? nickname,
      @JsonKey(name: "product") String? product,
      @JsonKey(name: "tiers_mode") dynamic tiersMode,
      @JsonKey(name: "transform_usage") dynamic transformUsage,
      @JsonKey(name: "trial_period_days") dynamic trialPeriodDays,
      @JsonKey(name: "usage_type") String? usageType});

  $MetadataCopyWith<$Res>? get metadata;
}

/// @nodoc
class _$PlanCreateCopyWithImpl<$Res, $Val extends PlanCreate>
    implements $PlanCreateCopyWith<$Res> {
  _$PlanCreateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? object = freezed,
    Object? active = freezed,
    Object? aggregateUsage = freezed,
    Object? amount = freezed,
    Object? amountDecimal = freezed,
    Object? billingScheme = freezed,
    Object? created = freezed,
    Object? currency = freezed,
    Object? interval = freezed,
    Object? intervalCount = freezed,
    Object? livemode = freezed,
    Object? metadata = freezed,
    Object? nickname = freezed,
    Object? product = freezed,
    Object? tiersMode = freezed,
    Object? transformUsage = freezed,
    Object? trialPeriodDays = freezed,
    Object? usageType = freezed,
  }) {
    return _then(_value.copyWith(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      object: freezed == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String?,
      active: freezed == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool?,
      aggregateUsage: freezed == aggregateUsage
          ? _value.aggregateUsage
          : aggregateUsage // ignore: cast_nullable_to_non_nullable
              as dynamic,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as int?,
      amountDecimal: freezed == amountDecimal
          ? _value.amountDecimal
          : amountDecimal // ignore: cast_nullable_to_non_nullable
              as String?,
      billingScheme: freezed == billingScheme
          ? _value.billingScheme
          : billingScheme // ignore: cast_nullable_to_non_nullable
              as String?,
      created: freezed == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int?,
      currency: freezed == currency
          ? _value.currency
          : currency // ignore: cast_nullable_to_non_nullable
              as String?,
      interval: freezed == interval
          ? _value.interval
          : interval // ignore: cast_nullable_to_non_nullable
              as String?,
      intervalCount: freezed == intervalCount
          ? _value.intervalCount
          : intervalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      livemode: freezed == livemode
          ? _value.livemode
          : livemode // ignore: cast_nullable_to_non_nullable
              as bool?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Metadata?,
      nickname: freezed == nickname
          ? _value.nickname
          : nickname // ignore: cast_nullable_to_non_nullable
              as String?,
      product: freezed == product
          ? _value.product
          : product // ignore: cast_nullable_to_non_nullable
              as String?,
      tiersMode: freezed == tiersMode
          ? _value.tiersMode
          : tiersMode // ignore: cast_nullable_to_non_nullable
              as dynamic,
      transformUsage: freezed == transformUsage
          ? _value.transformUsage
          : transformUsage // ignore: cast_nullable_to_non_nullable
              as dynamic,
      trialPeriodDays: freezed == trialPeriodDays
          ? _value.trialPeriodDays
          : trialPeriodDays // ignore: cast_nullable_to_non_nullable
              as dynamic,
      usageType: freezed == usageType
          ? _value.usageType
          : usageType // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $MetadataCopyWith<$Res>? get metadata {
    if (_value.metadata == null) {
      return null;
    }

    return $MetadataCopyWith<$Res>(_value.metadata!, (value) {
      return _then(_value.copyWith(metadata: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PlanCreateImplCopyWith<$Res>
    implements $PlanCreateCopyWith<$Res> {
  factory _$$PlanCreateImplCopyWith(
          _$PlanCreateImpl value, $Res Function(_$PlanCreateImpl) then) =
      __$$PlanCreateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(name: "id") String? id,
      @JsonKey(name: "object") String? object,
      @JsonKey(name: "active") bool? active,
      @JsonKey(name: "aggregate_usage") dynamic aggregateUsage,
      @JsonKey(name: "amount") int? amount,
      @JsonKey(name: "amount_decimal") String? amountDecimal,
      @JsonKey(name: "billing_scheme") String? billingScheme,
      @JsonKey(name: "created") int? created,
      @JsonKey(name: "currency") String? currency,
      @JsonKey(name: "interval") String? interval,
      @JsonKey(name: "interval_count") int? intervalCount,
      @JsonKey(name: "livemode") bool? livemode,
      @JsonKey(name: "metadata") Metadata? metadata,
      @JsonKey(name: "nickname") String? nickname,
      @JsonKey(name: "product") String? product,
      @JsonKey(name: "tiers_mode") dynamic tiersMode,
      @JsonKey(name: "transform_usage") dynamic transformUsage,
      @JsonKey(name: "trial_period_days") dynamic trialPeriodDays,
      @JsonKey(name: "usage_type") String? usageType});

  @override
  $MetadataCopyWith<$Res>? get metadata;
}

/// @nodoc
class __$$PlanCreateImplCopyWithImpl<$Res>
    extends _$PlanCreateCopyWithImpl<$Res, _$PlanCreateImpl>
    implements _$$PlanCreateImplCopyWith<$Res> {
  __$$PlanCreateImplCopyWithImpl(
      _$PlanCreateImpl _value, $Res Function(_$PlanCreateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = freezed,
    Object? object = freezed,
    Object? active = freezed,
    Object? aggregateUsage = freezed,
    Object? amount = freezed,
    Object? amountDecimal = freezed,
    Object? billingScheme = freezed,
    Object? created = freezed,
    Object? currency = freezed,
    Object? interval = freezed,
    Object? intervalCount = freezed,
    Object? livemode = freezed,
    Object? metadata = freezed,
    Object? nickname = freezed,
    Object? product = freezed,
    Object? tiersMode = freezed,
    Object? transformUsage = freezed,
    Object? trialPeriodDays = freezed,
    Object? usageType = freezed,
  }) {
    return _then(_$PlanCreateImpl(
      id: freezed == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String?,
      object: freezed == object
          ? _value.object
          : object // ignore: cast_nullable_to_non_nullable
              as String?,
      active: freezed == active
          ? _value.active
          : active // ignore: cast_nullable_to_non_nullable
              as bool?,
      aggregateUsage: freezed == aggregateUsage
          ? _value.aggregateUsage
          : aggregateUsage // ignore: cast_nullable_to_non_nullable
              as dynamic,
      amount: freezed == amount
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as int?,
      amountDecimal: freezed == amountDecimal
          ? _value.amountDecimal
          : amountDecimal // ignore: cast_nullable_to_non_nullable
              as String?,
      billingScheme: freezed == billingScheme
          ? _value.billingScheme
          : billingScheme // ignore: cast_nullable_to_non_nullable
              as String?,
      created: freezed == created
          ? _value.created
          : created // ignore: cast_nullable_to_non_nullable
              as int?,
      currency: freezed == currency
          ? _value.currency
          : currency // ignore: cast_nullable_to_non_nullable
              as String?,
      interval: freezed == interval
          ? _value.interval
          : interval // ignore: cast_nullable_to_non_nullable
              as String?,
      intervalCount: freezed == intervalCount
          ? _value.intervalCount
          : intervalCount // ignore: cast_nullable_to_non_nullable
              as int?,
      livemode: freezed == livemode
          ? _value.livemode
          : livemode // ignore: cast_nullable_to_non_nullable
              as bool?,
      metadata: freezed == metadata
          ? _value.metadata
          : metadata // ignore: cast_nullable_to_non_nullable
              as Metadata?,
      nickname: freezed == nickname
          ? _value.nickname
          : nickname // ignore: cast_nullable_to_non_nullable
              as String?,
      product: freezed == product
          ? _value.product
          : product // ignore: cast_nullable_to_non_nullable
              as String?,
      tiersMode: freezed == tiersMode
          ? _value.tiersMode
          : tiersMode // ignore: cast_nullable_to_non_nullable
              as dynamic,
      transformUsage: freezed == transformUsage
          ? _value.transformUsage
          : transformUsage // ignore: cast_nullable_to_non_nullable
              as dynamic,
      trialPeriodDays: freezed == trialPeriodDays
          ? _value.trialPeriodDays
          : trialPeriodDays // ignore: cast_nullable_to_non_nullable
              as dynamic,
      usageType: freezed == usageType
          ? _value.usageType
          : usageType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PlanCreateImpl implements _PlanCreate {
  const _$PlanCreateImpl(
      {@JsonKey(name: "id") this.id,
      @JsonKey(name: "object") this.object,
      @JsonKey(name: "active") this.active,
      @JsonKey(name: "aggregate_usage") this.aggregateUsage,
      @JsonKey(name: "amount") this.amount,
      @JsonKey(name: "amount_decimal") this.amountDecimal,
      @JsonKey(name: "billing_scheme") this.billingScheme,
      @JsonKey(name: "created") this.created,
      @JsonKey(name: "currency") this.currency,
      @JsonKey(name: "interval") this.interval,
      @JsonKey(name: "interval_count") this.intervalCount,
      @JsonKey(name: "livemode") this.livemode,
      @JsonKey(name: "metadata") this.metadata,
      @JsonKey(name: "nickname") this.nickname,
      @JsonKey(name: "product") this.product,
      @JsonKey(name: "tiers_mode") this.tiersMode,
      @JsonKey(name: "transform_usage") this.transformUsage,
      @JsonKey(name: "trial_period_days") this.trialPeriodDays,
      @JsonKey(name: "usage_type") this.usageType});

  factory _$PlanCreateImpl.fromJson(Map<String, dynamic> json) =>
      _$$PlanCreateImplFromJson(json);

  @override
  @JsonKey(name: "id")
  final String? id;
  @override
  @JsonKey(name: "object")
  final String? object;
  @override
  @JsonKey(name: "active")
  final bool? active;
  @override
  @JsonKey(name: "aggregate_usage")
  final dynamic aggregateUsage;
  @override
  @JsonKey(name: "amount")
  final int? amount;
  @override
  @JsonKey(name: "amount_decimal")
  final String? amountDecimal;
  @override
  @JsonKey(name: "billing_scheme")
  final String? billingScheme;
  @override
  @JsonKey(name: "created")
  final int? created;
  @override
  @JsonKey(name: "currency")
  final String? currency;
  @override
  @JsonKey(name: "interval")
  final String? interval;
  @override
  @JsonKey(name: "interval_count")
  final int? intervalCount;
  @override
  @JsonKey(name: "livemode")
  final bool? livemode;
  @override
  @JsonKey(name: "metadata")
  final Metadata? metadata;
  @override
  @JsonKey(name: "nickname")
  final String? nickname;
  @override
  @JsonKey(name: "product")
  final String? product;
  @override
  @JsonKey(name: "tiers_mode")
  final dynamic tiersMode;
  @override
  @JsonKey(name: "transform_usage")
  final dynamic transformUsage;
  @override
  @JsonKey(name: "trial_period_days")
  final dynamic trialPeriodDays;
  @override
  @JsonKey(name: "usage_type")
  final String? usageType;

  @override
  String toString() {
    return 'PlanCreate(id: $id, object: $object, active: $active, aggregateUsage: $aggregateUsage, amount: $amount, amountDecimal: $amountDecimal, billingScheme: $billingScheme, created: $created, currency: $currency, interval: $interval, intervalCount: $intervalCount, livemode: $livemode, metadata: $metadata, nickname: $nickname, product: $product, tiersMode: $tiersMode, transformUsage: $transformUsage, trialPeriodDays: $trialPeriodDays, usageType: $usageType)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PlanCreateImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.object, object) || other.object == object) &&
            (identical(other.active, active) || other.active == active) &&
            const DeepCollectionEquality()
                .equals(other.aggregateUsage, aggregateUsage) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.amountDecimal, amountDecimal) ||
                other.amountDecimal == amountDecimal) &&
            (identical(other.billingScheme, billingScheme) ||
                other.billingScheme == billingScheme) &&
            (identical(other.created, created) || other.created == created) &&
            (identical(other.currency, currency) ||
                other.currency == currency) &&
            (identical(other.interval, interval) ||
                other.interval == interval) &&
            (identical(other.intervalCount, intervalCount) ||
                other.intervalCount == intervalCount) &&
            (identical(other.livemode, livemode) ||
                other.livemode == livemode) &&
            (identical(other.metadata, metadata) ||
                other.metadata == metadata) &&
            (identical(other.nickname, nickname) ||
                other.nickname == nickname) &&
            (identical(other.product, product) || other.product == product) &&
            const DeepCollectionEquality().equals(other.tiersMode, tiersMode) &&
            const DeepCollectionEquality()
                .equals(other.transformUsage, transformUsage) &&
            const DeepCollectionEquality()
                .equals(other.trialPeriodDays, trialPeriodDays) &&
            (identical(other.usageType, usageType) ||
                other.usageType == usageType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        id,
        object,
        active,
        const DeepCollectionEquality().hash(aggregateUsage),
        amount,
        amountDecimal,
        billingScheme,
        created,
        currency,
        interval,
        intervalCount,
        livemode,
        metadata,
        nickname,
        product,
        const DeepCollectionEquality().hash(tiersMode),
        const DeepCollectionEquality().hash(transformUsage),
        const DeepCollectionEquality().hash(trialPeriodDays),
        usageType
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PlanCreateImplCopyWith<_$PlanCreateImpl> get copyWith =>
      __$$PlanCreateImplCopyWithImpl<_$PlanCreateImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PlanCreateImplToJson(
      this,
    );
  }
}

abstract class _PlanCreate implements PlanCreate {
  const factory _PlanCreate(
      {@JsonKey(name: "id") final String? id,
      @JsonKey(name: "object") final String? object,
      @JsonKey(name: "active") final bool? active,
      @JsonKey(name: "aggregate_usage") final dynamic aggregateUsage,
      @JsonKey(name: "amount") final int? amount,
      @JsonKey(name: "amount_decimal") final String? amountDecimal,
      @JsonKey(name: "billing_scheme") final String? billingScheme,
      @JsonKey(name: "created") final int? created,
      @JsonKey(name: "currency") final String? currency,
      @JsonKey(name: "interval") final String? interval,
      @JsonKey(name: "interval_count") final int? intervalCount,
      @JsonKey(name: "livemode") final bool? livemode,
      @JsonKey(name: "metadata") final Metadata? metadata,
      @JsonKey(name: "nickname") final String? nickname,
      @JsonKey(name: "product") final String? product,
      @JsonKey(name: "tiers_mode") final dynamic tiersMode,
      @JsonKey(name: "transform_usage") final dynamic transformUsage,
      @JsonKey(name: "trial_period_days") final dynamic trialPeriodDays,
      @JsonKey(name: "usage_type") final String? usageType}) = _$PlanCreateImpl;

  factory _PlanCreate.fromJson(Map<String, dynamic> json) =
      _$PlanCreateImpl.fromJson;

  @override
  @JsonKey(name: "id")
  String? get id;
  @override
  @JsonKey(name: "object")
  String? get object;
  @override
  @JsonKey(name: "active")
  bool? get active;
  @override
  @JsonKey(name: "aggregate_usage")
  dynamic get aggregateUsage;
  @override
  @JsonKey(name: "amount")
  int? get amount;
  @override
  @JsonKey(name: "amount_decimal")
  String? get amountDecimal;
  @override
  @JsonKey(name: "billing_scheme")
  String? get billingScheme;
  @override
  @JsonKey(name: "created")
  int? get created;
  @override
  @JsonKey(name: "currency")
  String? get currency;
  @override
  @JsonKey(name: "interval")
  String? get interval;
  @override
  @JsonKey(name: "interval_count")
  int? get intervalCount;
  @override
  @JsonKey(name: "livemode")
  bool? get livemode;
  @override
  @JsonKey(name: "metadata")
  Metadata? get metadata;
  @override
  @JsonKey(name: "nickname")
  String? get nickname;
  @override
  @JsonKey(name: "product")
  String? get product;
  @override
  @JsonKey(name: "tiers_mode")
  dynamic get tiersMode;
  @override
  @JsonKey(name: "transform_usage")
  dynamic get transformUsage;
  @override
  @JsonKey(name: "trial_period_days")
  dynamic get trialPeriodDays;
  @override
  @JsonKey(name: "usage_type")
  String? get usageType;
  @override
  @JsonKey(ignore: true)
  _$$PlanCreateImplCopyWith<_$PlanCreateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

Metadata _$MetadataFromJson(Map<String, dynamic> json) {
  return _Metadata.fromJson(json);
}

/// @nodoc
mixin _$Metadata {
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MetadataCopyWith<$Res> {
  factory $MetadataCopyWith(Metadata value, $Res Function(Metadata) then) =
      _$MetadataCopyWithImpl<$Res, Metadata>;
}

/// @nodoc
class _$MetadataCopyWithImpl<$Res, $Val extends Metadata>
    implements $MetadataCopyWith<$Res> {
  _$MetadataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$MetadataImplCopyWith<$Res> {
  factory _$$MetadataImplCopyWith(
          _$MetadataImpl value, $Res Function(_$MetadataImpl) then) =
      __$$MetadataImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MetadataImplCopyWithImpl<$Res>
    extends _$MetadataCopyWithImpl<$Res, _$MetadataImpl>
    implements _$$MetadataImplCopyWith<$Res> {
  __$$MetadataImplCopyWithImpl(
      _$MetadataImpl _value, $Res Function(_$MetadataImpl) _then)
      : super(_value, _then);
}

/// @nodoc
@JsonSerializable()
class _$MetadataImpl implements _Metadata {
  const _$MetadataImpl();

  factory _$MetadataImpl.fromJson(Map<String, dynamic> json) =>
      _$$MetadataImplFromJson(json);

  @override
  String toString() {
    return 'Metadata()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MetadataImpl);
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => runtimeType.hashCode;

  @override
  Map<String, dynamic> toJson() {
    return _$$MetadataImplToJson(
      this,
    );
  }
}

abstract class _Metadata implements Metadata {
  const factory _Metadata() = _$MetadataImpl;

  factory _Metadata.fromJson(Map<String, dynamic> json) =
      _$MetadataImpl.fromJson;
}
